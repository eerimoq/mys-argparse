class _Option:

    name: string
    short: string
    takes_value: bool
    default: string
    multiple_occurrences: bool
    help: string

    def __init__(self,
                 name: string,
                 short: string,
                 takes_value: bool,
                 default: string,
                 multiple_occurrences: bool,
                 help: string):
        if default is not None and multiple_occurrences:
            raise Exception(
                "multiple occurrences options can not have a default value")

        self.name = name
        self.short = short
        self.default = default
        self.takes_value = takes_value

        if default is not None:
            self.takes_value = True

        self.multiple_occurrences = multiple_occurrences
        self.help = help

    def is_flag(self) -> bool:
        return self.is_single_flag() or self.is_multiple_flag()

    def is_single_flag(self) -> bool:
        return not self.takes_value and not self.multiple_occurrences

    def is_multiple_flag(self) -> bool:
        return not self.takes_value and self.multiple_occurrences

    def is_single_value(self) -> bool:
        return self.takes_value and not self.multiple_occurrences

    def is_multiple_value(self) -> bool:
        return self.takes_value and self.multiple_occurrences

class _Positional:

    name: string
    multiple_occurrences: bool
    help: string

    def is_single_value(self) -> bool:
        return not self.multiple_occurrences

class _Reader:

    args: [string]
    pos: u32

    def available(self) -> bool:
        return self.pos < len(self.args)

    def get(self) -> string:
        if self.pos == len(self.args):
            raise Exception("out of data")

        arg = self.args[self.pos]
        self.pos += 1

        return arg

    def unget(self):
        self.pos -= 1

class Args:

    _options: {string: u32}
    _single_values: {string: string}
    _multiple_values: {string: [string]}
    _subcommand: (string, Args)

    def is_present(self, arg: string) -> bool:
        """Returns true if given argument is present, false otherwise.

        """

        return self.occurrences_of(arg) > 0

    def occurrences_of(self, arg: string) -> u32:
        """Returns the number of times given presence (boolean) option was
        given.

        """

        return self._options[arg]

    def value_of(self, arg: string) -> string:
        """Returns the value of given option or positional. Raises an error
        if given option does not take a value or if given positional can be
        given multiple times.

        """

        return self._single_values[arg]

    def values_of(self, arg: string) -> [string]:
        """Returns a list of values of given multiple occurrences option or
        positional.

        """

        return self._multiple_values[arg]

    def subcommand(self) -> (string, Args):
        """Returns a tuple of the subcommand and its arguments, or (None, None)
        if no subcommand was found.

        """

        return self._subcommand

class Parser:

    name: string
    help: string
    version: string
    _parent: weak[Parser]
    _options: [_Option]
    _positionals: [_Positional]
    _subcommands: [Parser]

    def __init__(self,
                 name: string,
                 help: string = None,
                 version: string = None,
                 parent: Parser = None):
        self.name = name
        self.help = help
        self.version = version
        self._parent = parent
        self._options = []
        self._positionals = []
        self._subcommands = []
        self._add_builtin_options()

    def add_option(self,
                   name: string,
                   short: string = None,
                   takes_value: bool = False,
                   default: string = None,
                   multiple_occurrences: bool = False,
                   help: string = None):
        """Add an option.

        """

        if self._subcommands or self._positionals:
            raise Exception(
                "options must be added before subcommands and positionals")

        self._options += _Option(name,
                                 short,
                                 takes_value,
                                 default,
                                 multiple_occurrences,
                                 help)

    def add_positional(self,
                       name: string,
                       multiple_occurrences: bool = False,
                       help: string = None):
        """Add a positional.

        """

        if self._subcommands:
            raise Exception("positionals and subparsers can not be mixed")

        if self._positionals:
            if self._positionals[-1].multiple_occurrences:
                raise Exception("only the last posistional can occur multiple times")

        self._positionals += _Positional(name,
                                         multiple_occurrences,
                                         help)

    def add_subcommand(self,
                       name: string,
                       help: string = None) -> Parser:
        """Add a subcommand.

        """

        if self._positionals:
            raise Exception("positionals and subparsers can not be mixed")

        parser = Parser(name, help=help, parent=self)
        self._subcommands += parser

        return parser

    def parse(self, args: [string]) -> Args:
        """Parse given arguments.

        """

        reader = _Reader(args, pos=1)

        return self._parse(reader)

    def print_help(self):
        prefix = self._format_usage_prefix()

        print(f"Usage: {prefix}{self.name} ...")

        if self.help is not None:
            print()
            print(self.help)

        self._print_subcommands_help()
        self._print_options_help()
        self._print_positionals_help()

    def _format_usage_prefix(self) -> string:
        if self._parent:
            prefix = self._parent._format_usage_prefix()

            return f"{prefix}{self._parent.name} "
        else:
            return ""

    def _print_subcommands_help(self):
        if not self._subcommands:
            return

        print()
        print("Commands:")
        print()

        for subcommand in self._subcommands:
            help = ""

            if subcommand.help is not None:
                help = subcommand.help

            print(f"  {subcommand.name} {help}")

    def _print_options_help(self):
        if not self._options:
            return

        print()
        print("Options:")
        print()

        for option in self._options:
            help = ""

            if option.help is not None:
                help = option.help

            if option.short:
                short = f"{option.short}, "
            else:
                short = ""

            print(f"  {short}{option.name} {help}")

    def _print_positionals_help(self):
        if not self._positionals:
            return

        print()
        print("Positionals:")
        print()

        for positional in self._positionals:
            help = ""

            if positional.help is not None:
                help = positional.help

            print(f"  {positional.name} {help}")

    def _find_option(self, name: string) -> _Option:
        for option in self._options:
            if option.name == name or option.short == name:
                return option

        raise Exception(f"invalid option '{name}'")

    def _short_to_long_option(self, short: string) -> string:
        for option in self._options:
            if option.short == short:
                return option.name

        raise Exception(f"invalid option '{short}'")

    def _expand_option(self, option: string) -> [string]:
        options = []

        if option.startswith("--"):
            options += option
        else:
            for short in option[1:]:
                options += self._short_to_long_option(f"-{short}")

        return options

    def _add_builtin_options(self):
        self.add_option("--help",
                        short="-h",
                        help="Show this help.")

        if self.version is not None:
            self.add_option("--version",
                            help="Show version infomation.")

    def _handle_builtin_options(self, name: string):
        if name == "--help":
            self.print_help()

            raise Exception()

        if name == "--version":
            print(self.version)

            raise Exception()

    def _parse_options(self,
                       reader: _Reader,
                       options: {string: u32},
                       single_values: {string: string},
                       multiple_values: {string: [string]}):
        while reader.available():
            name = reader.get()

            if not name.startswith("-"):
                reader.unget()
                break

            if name == "--":
                break

            for name in self._expand_option(name):
                option = self._find_option(name)

                self._handle_builtin_options(name)

                if option.is_single_flag():
                    if options[name] > 0:
                        raise Exception(f"'{name}' can only be given once")

                    options[name] = 1
                elif option.is_multiple_flag():
                    options[name] += 1
                elif option.is_single_value():
                    if single_values[name] is not None:
                        raise Exception(f"'{name}' can only be given once")

                    single_values[name] = reader.get()
                else:
                    multiple_values[name] += reader.get()

    def _find_subcommand(self, name: string) -> string:
        for subcommand in self._subcommands:
            if subcommand.name == name:
                return subcommand

        raise Exception(f"invalid subcommand '{name}'")

    def _parse_subcommand(self, reader: _Reader) -> (string, Args):
        if not reader.available():
            return (None, None)

        subcommand = self._find_subcommand(reader.get())

        return (name, subcommand._parse(reader))

    def _get_positional_value(self,
                              name: string,
                              reader: _Reader) -> string:
        if not reader.available():
            raise Exception(f"positional argument '{name}' missing")

        return reader.get()

    def _parse_positionals(self,
                           reader: _Reader,
                           single_values: {string: string},
                           multiple_values: {string: [string]}):
        for positional in self._positionals:
            name = positional.name
            value = self._get_positional_value(name, reader)

            if positional.is_single_value():
                single_values[name] = value
            else:
                multiple_values[name] = [value]

                while reader.available():
                    multiple_values[name] += reader.get()

    def _parse(self, reader: _Reader) -> Args:
        options: {string: u32} = {}
        single_values: {string: string} = {}
        multiple_values: {string: [string]} = {}
        subcommand: (string, Args) = (None, None)

        for option in self._options:
            if option.is_flag():
                options[option.name] = 0
            elif option.is_single_value():
                single_values[option.name] = option.default
            elif option.is_multiple_value():
                multiple_values[option.name] = []

        self._parse_options(reader, options, single_values, multiple_values)

        if self._subcommands:
            subcommand = self._parse_subcommand(reader)
        else:
            self._parse_positionals(reader, single_values, multiple_values)

        if reader.available():
            raise Exception("all arguments were not used")

        return Args(options, single_values, multiple_values, subcommand)

@test
def test_various():
    parser = Parser("foo",
                    help="Does awesome things",
                    version="1.0.0")
    parser.add_option("--verbose",
                      short="-v",
                      multiple_occurrences=True,
                      help="Verbose output.")

    monkey = parser.add_subcommand("monkey", help="Some more stuff.")
    monkey.add_option("--height", default="80")
    monkey.add_positional("banana", multiple_occurrences=True, help="Banana?")

    cat = parser.add_subcommand("cat", help="What?")
    cat.add_option("--auto", short="-a")
    cat.add_option("--rate", default="10000")
    cat.add_positional("food")

    args = parser.parse(['foo'])
    assert_eq(args.occurrences_of("--verbose"), 0)
    assert_eq(args.subcommand(), (None, None))

    args = parser.parse(['foo', '--verbose'])
    assert_eq(args.occurrences_of("--verbose"), 1)

    args = parser.parse(['foo', '-vvv'])
    assert_eq(args.occurrences_of("--verbose"), 3)

    args = parser.parse(['foo', 'cat', '--auto', 'rat'])
    assert_true(args.is_present('--verbose'))
    name, args = args.subcommand()
    assert_eq(name, 'cat')
    assert_true(args.is_present('--auto'))
    assert_true(args.value_of('--rate'), "10000")
    assert_eq(args.value_of('food'), 'rat')
